from flask import Blueprint, render_template, request, redirect, url_for, flash, send_file
import subprocess
import os
from datetime import datetime
from werkzeug.utils import secure_filename
import tempfile
import glob

database_bp = Blueprint('database', __name__, url_prefix='/database')

# 数据库配置（从 run.py 中获取）
DB_HOST = 'localhost'
DB_USER = 'root'
DB_PASSWORD = 'root'
DB_NAME = 'pharmacy_db'

# 备份文件存储目录
BACKUP_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'backups')

# 确保备份目录存在
if not os.path.exists(BACKUP_DIR):
    os.makedirs(BACKUP_DIR)


def find_mysql_bin():
    """自动查找 MySQL bin 目录"""
    # 常见的 MySQL 安装路径
    possible_paths = [
        r"C:\Program Files\MySQL\MySQL Server 8.0\bin",
        r"C:\Program Files\MySQL\MySQL Server 8.1\bin",
        r"C:\Program Files\MySQL\MySQL Server 8.2\bin",
        r"C:\Program Files\MySQL\MySQL Server 5.7\bin",
        r"C:\Program Files (x86)\MySQL\MySQL Server 8.0\bin",
        r"C:\Program Files (x86)\MySQL\MySQL Server 5.7\bin",
        r"C:\xampp\mysql\bin",
        r"C:\wamp64\bin\mysql\mysql8.0.27\bin",
        r"D:\MySQL\MySQL Server 8.0\bin",
        r"D:\Program Files\MySQL\MySQL Server 8.0\bin",
    ]

    # 使用通配符搜索
    search_patterns = [
        r"C:\Program Files\MySQL\MySQL Server*\bin",
        r"C:\Program Files (x86)\MySQL\MySQL Server*\bin",
        r"D:\Program Files\MySQL\MySQL Server*\bin",
    ]

    # 先检查固定路径
    for path in possible_paths:
        mysqldump_path = os.path.join(path, 'mysqldump.exe')
        mysql_path = os.path.join(path, 'mysql.exe')
        if os.path.exists(mysqldump_path) and os.path.exists(mysql_path):
            return path

    # 再使用通配符搜索
    for pattern in search_patterns:
        matches = glob.glob(pattern)
        for path in matches:
            mysqldump_path = os.path.join(path, 'mysqldump.exe')
            mysql_path = os.path.join(path, 'mysql.exe')
            if os.path.exists(mysqldump_path) and os.path.exists(mysql_path):
                return path

    # 如果都找不到，返回 None（使用系统 PATH）
    return None


def get_mysql_command(command_name):
    """获取 MySQL 命令的完整路径"""
    mysql_bin = find_mysql_bin()
    if mysql_bin:
        return os.path.join(mysql_bin, f'{command_name}.exe')
    else:
        # 如果找不到，尝试使用 PATH 中的命令
        return command_name


@database_bp.route('/manage')
def database_manage():
    """数据库管理主页"""
    # 获取已有的备份文件列表
    backups = []
    if os.path.exists(BACKUP_DIR):
        for filename in os.listdir(BACKUP_DIR):
            if filename.endswith('.sql'):
                filepath = os.path.join(BACKUP_DIR, filename)
                file_size = os.path.getsize(filepath) / 1024  # KB
                file_time = datetime.fromtimestamp(os.path.getmtime(filepath))
                backups.append({
                    'filename': filename,
                    'size': f"{file_size:.2f} KB",
                    'time': file_time.strftime('%Y-%m-%d %H:%M:%S')
                })
    # 按时间倒序排列
    backups.sort(key=lambda x: x['time'], reverse=True)

    # 检测 MySQL 安装路径
    mysql_bin = find_mysql_bin()
    mysql_status = {
        'found': mysql_bin is not None,
        'path': mysql_bin if mysql_bin else '未找到',
        'mysqldump_exists': os.path.exists(os.path.join(mysql_bin, 'mysqldump.exe')) if mysql_bin else False,
        'mysql_exists': os.path.exists(os.path.join(mysql_bin, 'mysql.exe')) if mysql_bin else False
    }

    return render_template('database_manage.html', backups=backups, mysql_status=mysql_status)


@database_bp.route('/export')
def database_export():
    """导出数据库（使用纯 Python 方案）"""
    try:
        from app import db
        import pymysql

        # 生成备份文件名（包含时间戳）
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f"pharmacy_db_backup_{timestamp}.sql"
        backup_path = os.path.join(BACKUP_DIR, backup_filename)

        # 连接数据库
        connection = pymysql.connect(
            host=DB_HOST,
            user=DB_USER,
            password=DB_PASSWORD,
            database=DB_NAME,
            charset='utf8mb4'
        )

        with open(backup_path, 'w', encoding='utf8') as f:
            cursor = connection.cursor()

            # 写入 SQL 文件头部
            f.write(f"-- MySQL Database Backup\n")
            f.write(f"-- Database: {DB_NAME}\n")
            f.write(f"-- Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"-- Generated by Pharmacy Management System\n\n")
            f.write("SET NAMES utf8mb4;\n")
            f.write("SET FOREIGN_KEY_CHECKS = 0;\n\n")

            # 获取所有表名
            cursor.execute("SHOW TABLES")
            tables = [table[0] for table in cursor.fetchall()]

            for table in tables:
                # 写入表结构
                f.write(f"-- ----------------------------\n")
                f.write(f"-- Table structure for {table}\n")
                f.write(f"-- ----------------------------\n")
                f.write(f"DROP TABLE IF EXISTS `{table}`;\n")

                cursor.execute(f"SHOW CREATE TABLE `{table}`")
                create_table = cursor.fetchone()[1]
                f.write(f"{create_table};\n\n")

                # 写入表数据
                cursor.execute(f"SELECT * FROM `{table}`")
                rows = cursor.fetchall()

                if rows:
                    f.write(f"-- ----------------------------\n")
                    f.write(f"-- Records of {table}\n")
                    f.write(f"-- ----------------------------\n")

                    # 获取列信息
                    cursor.execute(f"SHOW COLUMNS FROM `{table}`")
                    columns = [col[0] for col in cursor.fetchall()]

                    for row in rows:
                        values = []
                        for value in row:
                            if value is None:
                                values.append('NULL')
                            elif isinstance(value, (int, float)):
                                values.append(str(value))
                            elif isinstance(value, datetime):
                                values.append(f"'{value.strftime('%Y-%m-%d %H:%M:%S')}'")
                            else:
                                # 转义特殊字符
                                value_str = str(value).replace('\\', '\\\\').replace("'", "\\'")
                                values.append(f"'{value_str}'")

                        f.write(f"INSERT INTO `{table}` VALUES ({', '.join(values)});\n")

                    f.write("\n")

            # 写入文件尾部
            f.write("SET FOREIGN_KEY_CHECKS = 1;\n")

        cursor.close()
        connection.close()

        flash(f'数据库导出成功：{backup_filename}', 'success')
        # 直接下载文件
        return send_file(
            backup_path,
            as_attachment=True,
            download_name=backup_filename,
            mimetype='application/sql'
        )

    except Exception as e:
        import traceback
        error_detail = traceback.format_exc()
        flash(f'导出数据库时发生错误：{str(e)}', 'error')
        print(f"导出错误详情：\n{error_detail}")  # 在控制台输出详细错误
        return redirect(url_for('database.database_manage'))


@database_bp.route('/import', methods=['POST'])
def database_import():
    """导入数据库（使用纯 Python 方案）"""
    if 'sql_file' not in request.files:
        flash('请选择要导入的SQL文件', 'error')
        return redirect(url_for('database.database_manage'))

    file = request.files['sql_file']
    if file.filename == '':
        flash('未选择文件', 'error')
        return redirect(url_for('database.database_manage'))

    if not file.filename.endswith('.sql'):
        flash('只能导入 .sql 文件', 'error')
        return redirect(url_for('database.database_manage'))

    try:
        import pymysql

        # 保存上传的文件到临时目录
        filename = secure_filename(file.filename)
        temp_path = os.path.join(tempfile.gettempdir(), filename)
        file.save(temp_path)

        # 读取 SQL 文件内容
        with open(temp_path, 'r', encoding='utf8') as f:
            sql_content = f.read()

        # 连接数据库
        connection = pymysql.connect(
            host=DB_HOST,
            user=DB_USER,
            password=DB_PASSWORD,
            database=DB_NAME,
            charset='utf8mb4'
        )

        cursor = connection.cursor()

        # 分割并执行 SQL 语句
        # 移除注释行
        sql_lines = []
        for line in sql_content.split('\n'):
            line = line.strip()
            if line and not line.startswith('--'):
                sql_lines.append(line)

        sql_content = ' '.join(sql_lines)

        # 按分号分割 SQL 语句
        statements = sql_content.split(';')

        for statement in statements:
            statement = statement.strip()
            if statement:
                try:
                    cursor.execute(statement)
                except Exception as e:
                    # 某些语句可能失败，但继续执行
                    print(f"执行 SQL 语句时出错（继续）: {str(e)}")

        connection.commit()
        cursor.close()
        connection.close()

        # 删除临时文件
        os.remove(temp_path)

        flash('数据库导入成功', 'success')

    except Exception as e:
        import traceback
        error_detail = traceback.format_exc()
        flash(f'导入数据库时发生错误：{str(e)}', 'error')
        print(f"导入错误详情：\n{error_detail}")

    return redirect(url_for('database.database_manage'))


@database_bp.route('/download/<filename>')
def database_download(filename):
    """下载备份文件"""
    try:
        # 安全检查：确保文件名不包含路径遍历字符
        filename = secure_filename(filename)
        filepath = os.path.join(BACKUP_DIR, filename)

        if not os.path.exists(filepath):
            flash('备份文件不存在', 'error')
            return redirect(url_for('database.database_manage'))

        return send_file(
            filepath,
            as_attachment=True,
            download_name=filename,
            mimetype='application/sql'
        )
    except Exception as e:
        flash(f'下载文件时发生错误：{str(e)}', 'error')
        return redirect(url_for('database.database_manage'))


@database_bp.route('/delete/<filename>')
def database_delete(filename):
    """删除备份文件"""
    try:
        # 安全检查
        filename = secure_filename(filename)
        filepath = os.path.join(BACKUP_DIR, filename)

        if os.path.exists(filepath):
            os.remove(filepath)
            flash(f'备份文件 {filename} 已删除', 'success')
        else:
            flash('备份文件不存在', 'error')
    except Exception as e:
        flash(f'删除文件时发生错误：{str(e)}', 'error')

    return redirect(url_for('database.database_manage'))
